# -*- coding: utf-8 -*-
""" QisKit backend for Quantum Inspire

@author: eendebakpt
"""

import warnings
import logging

import numpy as np
import time
import random
import copy
from collections import Counter
import uuid

from qiskit._result import Result
from qiskit.backends import BaseBackend
# from qiskit.backends.local.localjob import LocalJob
from qiskit.backends.local._simulatorerror import SimulatorError
from qiskit.backends.local._simulatortools import single_gate_matrix

logger = logging.getLogger(__name__)


class QiSimulatorPy(BaseBackend):
    """ Python implementation of a quantum simulator using Quantum Inspire
    
    Code adapted from https://github.com/Qiskit/qiskit-terra

# for definition of the u1, u2, u3 basis gates see   
# https://quantumexperience.ng.bluemix.net/proxy/tutorial/full-user-guide/002-The_Weird_and_Wonderful_World_of_the_Qubit/004-advanced_qubit_gates.html    
# also see: http://www.vcpc.univie.ac.at/~ian/hotlist/qc/talks/bloch-sphere-rotations.pdf
# note: Rz(theta)=\exp(-i theta/2 Z)

    """

    DEFAULT_CONFIGURATION = {
        'name': 'local_qi_simulator_py',
        'qi_backend_name': 'QX Single-node Simulator',
        'url': 'https://www.quantum-inspire.com/',
        'simulator': True,
        'local': True,
        'description': 'A qi simulator for qasm files',
        'coupling_map': 'all-to-all',
        'basis_gates': 'x,y,z,h,s,cx,u1,u2,u3,id,snapshot'
    }

    def __init__(self, configuration=None, qi_api=None):
        """
        Args:
            configuration (dict): backend configuration
        """
        super().__init__(configuration or self.DEFAULT_CONFIGURATION.copy())

        self.qi_api = qi_api

        backend_types = list(filter(
            lambda backend: backend['name'] == self._configuration['qi_backend_name'],
            self.qi_api.list_backend_types()
        ))

        if len(backend_types) != 1:
            raise Exception("Unable to find one backend with ")

        self._backend = backend_types[0]

        self._local_random = random.Random()

        # Define attributes in __init__.
        self._number_of_qubits = 0
        self._shots = 0
        self._snapshots = {}
        self._number_of_cbits = 0
        self._seed = 1

        self.verbose = 1

        self._cqasm = None
        self._qi_results = None

    def run(self, q_job):
        """Run q_job asynchronously.

        Args:
            q_job (QuantumJob/dict): QuantumJob object

        Returns:
            LocalJob: derived from BaseJob
        """
        return self._run_job(q_job)

    def _run_job(self, qobj):
        """Run circuits in q_job"""
        if self.verbose >= 2:
            print('_run_job')
        # qobj = q_job.qobj
        self._validate(qobj)
        result_list = []
        self._shots = qobj['config']['shots']
        start = time.time()
        for circuit in qobj['circuits']:
            result_list.append(self.run_circuit(circuit))
        end = time.time()
        job_id = str(uuid.uuid4())
        result = {'backend': self._configuration['name'],
                  'id': qobj['id'],
                  'job_id': job_id,
                  'result': result_list,
                  'status': 'COMPLETED',
                  'success': True,
                  'time_taken': (end - start)}
        return Result(result)

    def generate_cqasm(self, ccircuit):

        number_of_qubits = ccircuit['header']['number_of_qubits']
        if self.verbose:
            print('generate_cqasm: %d qubits\n' % number_of_qubits)
        ss = 'version 1.0\n'
        ss += '# cqasm generated by QI backend for QisKit\n'
        ss += 'qubits %d\n' % number_of_qubits

        for c in ccircuit['operations']:
            if self.verbose >= 2:
                print('%s: parsing %s' % (self.__class__, c,))
            if c['name'] == 'cx' or c['name'] == 'CX':
                ss += 'CNOT q[%d], q[%d]\n' % tuple(c['qubits'])
            elif c['name'] == 'measure':
                pass
            elif c['name'] == 'h':
                ss += 'H q[%d]\n' % tuple(c['qubits'])
            elif c['name'] == 'barrier':
                pass
                # ss+='id q[0]'
            elif c['name'] == 'id':
                pass
            elif c['name'] == 'u0':
                pass
            elif c['name'] == 'x':
                ss += 'X q[%d]\n' % tuple(c['qubits'])
            elif c['name'] == 'u1':
                if self.verbose >= 2:
                    print('u1: params %s' % (c['params'],))
                p = c['params']
                if p[0] == np.pi / 2:
                    ss += 'S q[%d]\n' % tuple(c['qubits'])
                elif p[0] == np.pi / 4:
                    ss += 'T q[%d]\n' % tuple(c['qubits'])
                elif p[0] == -np.pi / 4:
                    ss += 'Tdag q[%d]\n' % tuple(c['qubits'])
                else:
                    raise Exception('not implemented %s (params %s)' % (c['name'], p))
            elif c['name'] == 'u2':
                p = c['params']
                if p[0] == 0 and p[1] == np.pi:
                    raise Exception('not implemented %s' % c['name'])
                else:
                    raise Exception('not implemented %s' % c['name'])
            elif c['name'] == 'U':
                p = c['params']
                if p[0] == 0 and p[1] == 0 and p[2] == np.pi / 2:
                    ss += 'S q[%d]]\n' % (c['qubits'][0],)
                elif p[0] == 0 and p[1] == 0 and p[2] == -np.pi / 2:
                    ss += 'Sdag q[%d]]\n' % (c['qubits'][0],)
                else:
                    raise Exception('not implemented %s' % c['name'])
            elif c['name'] == 'u3':

                # the u3 operation is defined at https://quantumexperience.ng.bluemix.net/qx/tutorial?sectionId=full-user-guide&page=002-The_Weird_and_Wonderful_World_of_the_Qubit~2F004-advanced_qubit_gates
                # we can decompose this as three rotations
                p = c['params']
                if 1:
                    qi = c['qubits'][0]
                    ss += 'Rz q[%d], %f\n' % (qi, p[0],)
                    ss += 'Ry q[%d], %f\n' % (qi, p[1],)
                    ss += 'Rz q[%d], %f\n' % (qi, p[2],)

                    pass
                else:
                    raise Exception('not implemented gate %s (params %s)' % (c['name'], p))
            else:
                raise Exception('not implemented gate %s' % c['name'])

        pad = '   '
        ss += '.measurement\n'

        # bug in qi
        # ss+=pad+'measure q[%s]\n' % ( ','.join([str(i) for i in range(number_of_qubits)]))
        for i in range(number_of_qubits):
            ss += pad + 'measure q[%d]\n' % i
        return ss

    def run_circuit(self, circuit):
        """Run a circuit and return a single Result.

        Args:
            circuit (dict): JSON circuit from qobj circuits list

        Returns:
            dict: A dictionary of results which looks something like::

                {
                "data":
                    {  #### DATA CAN BE A DIFFERENT DICTIONARY FOR EACH BACKEND ####
                    "counts": {'00000': XXXX, '00001': XXXXX},
                    "time"  : xx.xxxxxxxx
                    },
                "status": --status (string)--
                }
        Raises:
            SimulatorError: if an error occurred.
        """
        compiled_circuit = circuit['compiled_circuit']
        self._number_of_qubits = compiled_circuit['header']['number_of_qubits']
        self._number_of_cbits = compiled_circuit['header']['number_of_clbits']

        start = time.time()

        number_of_shots = self._shots
        print('run_circuit: number_of_shots %d' % (number_of_shots,))
        self._cqasm = self.generate_cqasm(compiled_circuit)

        # execute cqasm
        results = self.qi_api.execute_qasm(self._cqasm, self._backend, number_of_shots=number_of_shots)
        self._qi_results = results

        counts = copy.copy(results['histogram'])
        for k in counts:
            counts[k] = counts[k] * number_of_shots
        data = {'counts': counts, 'snapshots': {}}

        end = time.time()
        return {'name': circuit['name'],
                'seed': None,
                'shots': self._shots,
                'data': data,
                'status': 'DONE',
                'success': True,
                'time_taken': (end - start)}

    @staticmethod
    def _validate(qobj):
        if qobj['config']['shots'] == 1:
            warnings.warn('The behavior of getting statevector from simulators '
                          'by setting shots=1 is deprecated and will be removed. '
                          'Use the local_statevector_simulator instead, or place '
                          'explicit snapshot instructions.',
                          DeprecationWarning)
        for circ in qobj['circuits']:
            if 'measure' not in [op['name'] for
                                 op in circ['compiled_circuit']['operations']]:
                logger.warning("no measurements in circuit '%s', "
                               "classical register will remain all zeros.", circ['name'])
        return

    def _format_result(self, counts, cl_reg_index, cl_reg_nbits):
        """Format the result bit string.

        This formats the result bit strings such that spaces are inserted
        at register divisions.

        Args:
            counts (dict): dictionary of counts e.g. {'1111': 1000, '0000':5}
            cl_reg_index (list): starting bit index of classical register
            cl_reg_nbits (list): total amount of bits in classical register
        Returns:
            dict: spaces inserted into dictionary keys at register boundaries.
        """
        fcounts = {}
        for key, value in counts.items():
            if cl_reg_nbits:
                new_key = [key[-cl_reg_nbits[0]:]]
                for index, nbits in zip(cl_reg_index[1:],
                                        cl_reg_nbits[1:]):
                    new_key.insert(0, key[-(index + nbits):-index])
                fcounts[' '.join(new_key)] = value
        return fcounts


class QiSimulatorPyMixed(BaseBackend):
    """Python implementation of a qasm simulator."""

    DEFAULT_CONFIGURATION = {
        'name': 'local_qi_simulator_py',
        'url': 'https://github.com/???',
        'simulator': True,
        'local': True,
        'description': 'A qi simulator for qasm files',
        'coupling_map': 'all-to-all',
        'basis_gates': 'x,y,z,h,s,cx,u1,u2,u3,id,snapshot'
    }

    def __init__(self, configuration=None):
        """
        Args:
            configuration (dict): backend configuration
        """
        super().__init__(configuration or self.DEFAULT_CONFIGURATION.copy())

        self._local_random = random.Random()

        # Define attributes in __init__.
        self._classical_state = 0
        self._statevector = 0
        self._snapshots = {}
        self._number_of_cbits = 0
        self._number_of_qubits = 0
        self._shots = 0
        self._seed = 1

    @staticmethod
    def _index1(b, i, k):
        """Magic index1 function.

        Takes a bitstring k and inserts bit b as the ith bit,
        shifting bits >= i over to make room.
        """
        retval = k
        lowbits = k & ((1 << i) - 1)  # get the low i bits

        retval >>= i
        retval <<= 1

        retval |= b

        retval <<= i
        retval |= lowbits

        return retval

    @staticmethod
    def _index2(b1, i1, b2, i2, k):
        """Magic index1 function.

        Takes a bitstring k and inserts bits b1 as the i1th bit
        and b2 as the i2th bit
        """
        assert i1 != i2

        if i1 > i2:
            # insert as (i1-1)th bit, will be shifted left 1 by next line
            retval = QiSimulatorPy._index1(b1, i1 - 1, k)
            retval = QiSimulatorPy._index1(b2, i2, retval)
        else:  # i2>i1
            # insert as (i2-1)th bit, will be shifted left 1 by next line
            retval = QiSimulatorPy._index1(b2, i2 - 1, k)
            retval = QiSimulatorPy._index1(b1, i1, retval)
        return retval

    def _add_qasm_single(self, gate, qubit):
        """Apply an arbitary 1-qubit operator to a qubit.

        Gate is the single qubit applied.
        qubit is the qubit the gate is applied to.
        """
        psi = self._statevector
        bit = 1 << qubit
        for k1 in range(0, 1 << self._number_of_qubits, 1 << (qubit + 1)):
            for k2 in range(0, 1 << qubit, 1):
                k = k1 | k2
                cache0 = psi[k]
                cache1 = psi[k | bit]
                psi[k] = gate[0, 0] * cache0 + gate[0, 1] * cache1
                psi[k | bit] = gate[1, 0] * cache0 + gate[1, 1] * cache1

    def _add_qasm_h(self, qubit):
        """Apply an arbitary 1-qubit operator to a qubit.

        Gate is the single qubit applied.
        qubit is the qubit the gate is applied to.
        """
        pass

    def _add_qasm_cx(self, q0, q1):
        """Optimized ideal CX on two qubits.

        q0 is the first qubit (control) counts from 0.
        q1 is the second qubit (target).
        """
        psi = self._statevector
        for k in range(0, 1 << (self._number_of_qubits - 2)):
            # first bit is control, second is target
            ind1 = self._index2(1, q0, 0, q1, k)
            # swap target if control is 1
            ind3 = self._index2(1, q0, 1, q1, k)
            cache0 = psi[ind1]
            cache1 = psi[ind3]
            psi[ind3] = cache0
            psi[ind1] = cache1

    def _add_qasm_decision(self, qubit):
        """Apply the decision of measurement/reset qubit gate.

        qubit is the qubit that is measured/reset
        """
        probability_zero = 0
        random_number = self._local_random.random()
        for ii in range(1 << self._number_of_qubits):
            if ii & (1 << qubit) == 0:
                probability_zero += np.abs(self._statevector[ii]) ** 2
        if random_number <= probability_zero:
            outcome = '0'
            norm = np.sqrt(probability_zero)
        else:
            outcome = '1'
            norm = np.sqrt(1 - probability_zero)
        return (outcome, norm)

    def _add_qasm_measure(self, qubit, cbit):
        """Apply the measurement qubit gate.

        qubit is the qubit measured.
        cbit is the classical bit the measurement is assigned to.
        """
        outcome, norm = self._add_qasm_decision(qubit)
        for ii in range(1 << self._number_of_qubits):
            # update quantum state
            if (ii >> qubit) & 1 == int(outcome):
                self._statevector[ii] = self._statevector[ii] / norm
            else:
                self._statevector[ii] = 0
        # update classical state
        bit = 1 << cbit
        self._classical_state = (self._classical_state & (~bit)) | (int(outcome) << cbit)

    def _add_qasm_reset(self, qubit):
        """Apply the reset to the qubit.

        This is done by doing a measruement and if 0 do nothing and
        if 1 flip the qubit.

        qubit is the qubit that is reset.
        """
        # TODO: slow, refactor later
        outcome, norm = self._add_qasm_decision(qubit)
        temp = np.copy(self._statevector)
        self._statevector.fill(0.0)
        # measurement
        for ii in range(1 << self._number_of_qubits):
            if (ii >> qubit) & 1 == int(outcome):
                temp[ii] = temp[ii] / norm
            else:
                temp[ii] = 0
        # reset
        if outcome == '1':
            for ii in range(1 << self._number_of_qubits):
                iip = (~ (1 << qubit)) & ii  # bit number qubit set to zero
                self._statevector[iip] += temp[ii]
        else:
            self._statevector = temp

    def _add_qasm_snapshot(self, slot):
        """Snapshot instruction to record simulator's internal representation
        of quantum statevector.

        slot is an integer indicating a snapshot slot number.
        """
        self._snapshots.setdefault(str(int(slot)),
                                   {}).setdefault("statevector",
                                                  []).append(np.copy(self._statevector))

    def run(self, q_job):
        """Run q_job asynchronously.

        Args:
            q_job (QuantumJob): QuantumJob object

        Returns:
            LocalJob: derived from BaseJob
        """
        print('run!')
        # return LocalJob(self._run_job, q_job)
        return self._run_job(q_job)

    def _run_job(self, q_job):
        """Run circuits in q_job"""
        print('_run_job')
        qobj = q_job.qobj
        self._validate(qobj)
        result_list = []
        self._shots = qobj['config']['shots']
        start = time.time()
        for circuit in qobj['circuits']:
            print('call run_circuit')
            result_list.append(self.run_circuit(circuit))
        end = time.time()
        job_id = str(uuid.uuid4())
        result = {'backend': self._configuration['name'],
                  'id': qobj['id'],
                  'job_id': job_id,
                  'result': result_list,
                  'status': 'COMPLETED',
                  'success': True,
                  'time_taken': (end - start)}
        return Result(result, qobj)

    def generate_cqasm(self, ccircuit):

        number_of_qubits = ccircuit['header']['number_of_qubits']
        print('generate_cqasm: %d qubits\n' % number_of_qubits)
        ss = 'version 1.0\n'
        ss += '# cqasm generated by QI backend for QisKit\n'
        ss += 'qubits %d\n' % number_of_qubits

        for c in ccircuit['operations']:
            print('parsing %s' % (c,))
            if c['name'] == 'cx' or c['name'] == 'CX':
                ss += 'CNOT q[%d], q[%d]\n' % tuple(c['qubits'])
            elif c['name'] == 'measure':
                pass
            elif c['name'] == 'h':
                ss += 'H q[%d]\n' % tuple(c['qubits'])
            elif c['name'] == 'x':
                ss += 'X q[%d]\n' % tuple(c['qubits'])
            elif c['name'] == 'u1':
                print('u1: params %s' % (c['params'],))
                p = c['params']
                if p[0] == np.pi / 2:
                    ss += 'S q[%d]\n' % tuple(c['qubits'])
                else:
                    raise Exception('not implemented')
            elif c['name'] == 'u2':
                p = c['params']
                if p[0] == 0 and p[1] == np.pi:
                    raise Exception('not implemented')
                else:
                    raise Exception('not implemented')
            elif c['name'] == 'U':
                p = c['params']
                if p[0] == 0 and p[1] == 0 and p[2] == np.pi / 2:
                    ss += 'S q[%d]]\n' % (c['qubits'][0],)
                elif p[0] == 0 and p[1] == 0 and p[2] == -np.pi / 2:
                    ss += 'Sdag q[%d]]\n' % (c['qubits'][0],)
                else:
                    raise Exception('not implemented')
            else:
                raise Exception('not implemented gate %s' % c['name'])

        pad = '   '
        ss += '.measurement\n'
        ss += pad + 'measure q[%s]\n' % (','.join([str(i) for i in range(number_of_qubits)]))
        return ss

    def run_circuit(self, circuit):
        """Run a circuit and return a single Result.

        Args:
            circuit (dict): JSON circuit from qobj circuits list

        Returns:
            dict: A dictionary of results which looks something like::

                {
                "data":
                    {  #### DATA CAN BE A DIFFERENT DICTIONARY FOR EACH BACKEND ####
                    "counts": {'00000': XXXX, '00001': XXXXX},
                    "time"  : xx.xxxxxxxx
                    },
                "status": --status (string)--
                }
        Raises:
            SimulatorError: if an error occurred.
        """
        ccircuit = circuit['compiled_circuit']
        self._number_of_qubits = ccircuit['header']['number_of_qubits']
        self._number_of_cbits = ccircuit['header']['number_of_clbits']

        self._cqasm = self.generate_cqasm(ccircuit)

        if 0:
            # execute cqasm

            return {'name': circuit['name'],
                    'seed': self._seed,
                    'shots': self._shots,
                    'data': data,
                    'status': 'DONE',
                    'success': True,
                    'time_taken': (end - start)}
        if 0:
            # run job...
            t0 = time.time()

            data = [129, 127]
            return {'name': circuit['name'],
                    'shots': self._shots,
                    'data': data,
                    'status': 'DONE',
                    'success': True,
                    'time_taken': (time.time() - t0)}

        self._statevector = 0
        self._classical_state = 0
        self._snapshots = {}
        cl_reg_index = []  # starting bit index of classical register
        cl_reg_nbits = []  # number of bits in classical register
        cbit_index = 0
        for cl_reg in ccircuit['header']['clbit_labels']:
            cl_reg_nbits.append(cl_reg[1])
            cl_reg_index.append(cbit_index)
            cbit_index += cl_reg[1]
        if circuit['config']['seed'] is None:
            self._seed = random.getrandbits(32)
        else:
            self._seed = circuit['config']['seed']
        self._local_random.seed(self._seed)
        outcomes = []

        start = time.time()
        for _ in range(self._shots):
            self._statevector = np.zeros(1 << self._number_of_qubits,
                                         dtype=complex)
            self._statevector[0] = 1
            self._classical_state = 0
            for operation in ccircuit['operations']:
                if 'conditional' in operation:
                    mask = int(operation['conditional']['mask'], 16)
                    if mask > 0:
                        value = self._classical_state & mask
                        while (mask & 0x1) == 0:
                            mask >>= 1
                            value >>= 1
                        if value != int(operation['conditional']['val'], 16):
                            continue
                # Check if single  gate
                if operation['name'] in ['U', 'u1', 'u2', 'u3']:
                    if 'params' in operation:
                        params = operation['params']
                    else:
                        params = None
                    qubit = operation['qubits'][0]
                    gate = single_gate_matrix(operation['name'], params)
                    self._add_qasm_single(gate, qubit)
                # Check if CX gate
                elif operation['name'] in ['x']:
                    qubit = operation['qubits'][0]
                    gate = single_gate_matrix('u3', [np.pi, 0, 0])
                    self._add_qasm_single(gate, qubit)

                elif operation['name'] in ['id', 'u0']:
                    pass
                elif operation['name'] in ['CX', 'cx']:
                    qubit0 = operation['qubits'][0]
                    qubit1 = operation['qubits'][1]
                    self._add_qasm_cx(qubit0, qubit1)
                elif operation['name'] in ['H', 'h']:
                    qubit0 = operation['qubits'][0]
                    self._add_qasm_h(qubit0)
                # Check if measure
                elif operation['name'] == 'measure':
                    qubit = operation['qubits'][0]
                    cbit = operation['clbits'][0]
                    self._add_qasm_measure(qubit, cbit)
                # Check if reset
                elif operation['name'] == 'reset':
                    qubit = operation['qubits'][0]
                    self._add_qasm_reset(qubit)
                # Check if barrier
                elif operation['name'] == 'barrier':
                    pass
                # Check if snapshot command
                elif operation['name'] == 'snapshot':
                    params = operation['params']
                    self._add_qasm_snapshot(params[0])
                else:
                    backend = self._configuration['name']
                    err_msg = '{0} encountered unrecognized operation "{1}"'
                    raise SimulatorError(err_msg.format(backend,
                                                        operation['name']))
            # Turn classical_state (int) into bit string
            outcomes.append(bin(self._classical_state)[2:].zfill(
                self._number_of_cbits))
        # Return the results
        counts = dict(Counter(outcomes))
        data = {'counts': self._format_result(
            counts, cl_reg_index, cl_reg_nbits)}
        data['snapshots'] = self._snapshots
        if self._shots == 1:
            # TODO: deprecated -- remove in v0.6
            data['statevector'] = self._statevector
            data['quantum_state'] = self._statevector
            data['classical_state'] = self._classical_state
        end = time.time()
        return {'name': circuit['name'],
                'seed': self._seed,
                'shots': self._shots,
                'data': data,
                'status': 'DONE',
                'success': True,
                'time_taken': (end - start)}

    def _validate(self, qobj):
        if qobj['config']['shots'] == 1:
            warnings.warn('The behavior of getting statevector from simulators '
                          'by setting shots=1 is deprecated and will be removed. '
                          'Use the local_statevector_simulator instead, or place '
                          'explicit snapshot instructions.',
                          DeprecationWarning)
        for circ in qobj['circuits']:
            if 'measure' not in [op['name'] for
                                 op in circ['compiled_circuit']['operations']]:
                logger.warning("no measurements in circuit '%s', "
                               "classical register will remain all zeros.", circ['name'])
        return

    @staticmethod
    def _format_result(counts, cl_reg_index, cl_reg_nbits):
        """Format the result bit string.

        This formats the result bit strings such that spaces are inserted
        at register divisions.

        Args:
            counts (dict): dictionary of counts e.g. {'1111': 1000, '0000':5}
            cl_reg_index (list): starting bit index of classical register
            cl_reg_nbits (list): total amount of bits in classical register
        Returns:
            dict: spaces inserted into dictionary keys at register boundaries.
        """
        fcounts = {}
        for key, value in counts.items():
            if cl_reg_nbits:
                new_key = [key[-cl_reg_nbits[0]:]]
                for index, nbits in zip(cl_reg_index[1:],
                                        cl_reg_nbits[1:]):
                    new_key.insert(0, key[-(index + nbits):-index])
                fcounts[' '.join(new_key)] = value
        return fcounts
