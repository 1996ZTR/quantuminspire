import io
import logging
import time
import uuid

import numpy as np
from qiskit._result import Result
from qiskit.backends import BaseBackend
from qiskit.backends.local._simulatorerror import SimulatorError


class QiSimulatorPy(BaseBackend):

    DEFAULT_CONFIGURATION = {
        'name': 'local_qi_simulator_py',
        'url': 'https://www.quantum-inspire.com/',
        'description': 'A Quantum Inspire Simulator for QASM files',
        'qi_backend_name': 'QX single-node simulator',
        'basis_gates': 'x,y,z,h,s,cx,ccx,u1,u2,u3,id,snapshot',
        'coupling_map': 'all-to-all',
        'simulator': True,
        'local': True
    }

    def __init__(self, api, configuration=None, logger=logging):
        """ Python implementation of a quantum simulator using Quantum Inspire.

        Args:
            configuration (dict): backend configuration
        """
        super().__init__(configuration or QiSimulatorPy.DEFAULT_CONFIGURATION)
        self.__backend_name = self.configuration['qi_backend_name']
        self.__backend = api.get_backend_type_by_name(self.__backend_name)
        self.__logger = logger
        self.__api = api
        self.execution_results = None
        self.number_of_shots = None
        self.compiled_qasm = None

    def run(self, job):
        """Run a quantum job asynchronously.

        Args:
            job (dict): The quantum job object.

        Returns:
            LocalJob: derived from BaseJob
        """
        start_time = time.time()

        self.__validate(job)
        self.number_of_shots = job['config']['shots']

        circuits = job['circuits']
        job_identifier = str(uuid.uuid4())
        result_list = [self.run_circuit(circuit) for circuit in circuits]
        execution_time = time.time() - start_time
        result = {'backend': self.__backend_name, 'id': job['id'], 'job_id': job_identifier,
                  'result': result_list, 'status': 'COMPLETED', 'success': True,
                  'time_taken': execution_time}
        return Result(result)

    def _generate_cqasm(self, compiled_circuits):
        number_of_qubits = compiled_circuits['header']['number_of_qubits']
        self.__logger.info('generate_cqasm: %d qubits\n' % number_of_qubits)
        with io.StringIO() as stream:
            stream.write('version 1.0\n')
            stream.write('# cqasm generated by QI backend for QisKit\n')
            stream.write('qubits %d\n' % number_of_qubits)
            for circuit in compiled_circuits:
                pass
                """
                modes = {'cx': 'CNOT q[%d], q[%d]\n' % tuple(circuit['qubits']),
                         'CX': 'CNOT q[%d], q[%d]\n' % tuple(circuit['qubits']),
                         'measure': break,
                         'h': 'H q[%d]\n' % tuple(circuit['qubits']),
                         'barrier': pass,
                         'id': pass,
                         'u0': pass,
                         'x': 'X q[%d]\n' % tuple(circuit['qubits']),
                         'u1': 'some_function'}
                """

            stream.write('.measurement\n')
            for qubit_index in range(number_of_qubits):
                stream.write('   measure q[%d]\n' % qubit_index)
            return stream.getvalue()

    def __generate_cqasm(self, compiled_circuits):
        number_of_qubits = compiled_circuits['header']['number_of_qubits']
        self.__logger.info('generate_cqasm: %d qubits\n' % number_of_qubits)
        ss = 'version 1.0\n'
        ss += '# cqasm generated by QI backend for QisKit\n'
        ss += 'qubits %d\n' % number_of_qubits

        for c in compiled_circuits['operations']:
            self.__logger.info('%s: parsing %s' % (self.__class__, c,))
            if c['name'] == 'cx' or c['name'] == 'CX':
                ss += 'CNOT q[%d], q[%d]\n' % tuple(c['qubits'])
            elif c['name'] == 'ccx':
                ss += 'Toffoli q[%d], q[%d], q[%d]\n' % tuple(c['qubits'])
            elif c['name'] == 'measure':
                pass
            elif c['name'] == 'h':
                ss += 'H q[%d]\n' % tuple(c['qubits'])
            elif c['name'] == 'barrier':
                pass
                # ss+='id q[0]'
            elif c['name'] == 'id':
                pass
            elif c['name'] == 'u0':
                pass
            elif c['name'] == 'x':
                ss += 'X q[%d]\n' % tuple(c['qubits'])
            elif c['name'] == 'u1':
                self.__logger.info('u1: params %s' % (c['params'],))
                p = c['params']
                if p[0] == np.pi / 2:
                    ss += 'S q[%d]\n' % tuple(c['qubits'])
                elif p[0] == np.pi / 4:
                    ss += 'T q[%d]\n' % tuple(c['qubits'])
                elif p[0] == -np.pi / 4:
                    ss += 'Tdag q[%d]\n' % tuple(c['qubits'])
                else:
                    raise Exception('not implemented %s (params %s)' % (c['name'], p))
            elif c['name'] == 'u2':
                p = c['params']
                if p[0] == 0 and p[1] == np.pi:
                    raise Exception('not implemented %s' % c['name'])
                else:
                    raise Exception('not implemented %s' % c['name'])
            elif c['name'] == 'U':
                p = c['params']
                if p[0] == 0 and p[1] == 0 and p[2] == np.pi / 2:
                    ss += 'S q[%d]]\n' % (c['qubits'][0],)
                elif p[0] == 0 and p[1] == 0 and p[2] == -np.pi / 2:
                    ss += 'Sdag q[%d]]\n' % (c['qubits'][0],)
                else:
                    raise Exception('not implemented %s' % c['name'])
            elif c['name'] == 'u3':
                p = c['params']
                if 1:
                    qi = c['qubits'][0]
                    ss += 'Rz q[%d], %f\n' % (qi, p[0],)
                    ss += 'Ry q[%d], %f\n' % (qi, p[1],)
                    ss += 'Rz q[%d], %f\n' % (qi, p[2],)
                    pass
                else:
                    raise Exception('Gate not implemented %s (params %s)' % (c['name'], p))
            else:
                raise Exception('Gate not implemented %s' % c['name'])

        pad = '   '
        ss += '.measurement\n'

        for i in range(number_of_qubits):
            ss += pad + 'measure q[%d]\n' % i
        return ss

    def run_circuit(self, circuit):
        """Run a circuit and return a single Result object.

        Args:
            circuit (dict): JSON circuit from quantum object with circuits list.

        Raises:
            SimulatorError: if an error occurred during execution by the backend.

        Returns:
            Dict: A dictionary with results.
        """
        start_time = time.time()
        print('Run circuit: number_of_shots {00}\n'.format(self.number_of_shots))

        compiled_circuit = circuit['compiled_circuit']
        self.compiled_qasm = self.__generate_cqasm(compiled_circuit)
        self.execution_results = self.__api.execute_qasm(self.compiled_qasm, self.__backend, self.number_of_shots)
        if len(self.execution_results['histogram']) == 0:
            raise SimulatorError('Result from backend contains no histogram data!')

        histogram = self.execution_results['histogram'].items()
        counts = {key: value * self.number_of_shots for key, value in histogram}
        data = {'counts': counts, 'snapshots': dict()}

        execution_time = time.time() - start_time
        print('Execution done in {0:.2g} seconds.\n'.format(execution_time))
        return {'name': circuit['name'], 'seed': None, 'shots': self.number_of_shots,
                'data': data, 'status': 'DONE', 'success': True, 'time_taken': execution_time}

    def __validate(self, quantum_object):
        circuits = quantum_object['circuits']
        number_of_shots = quantum_object['config']['shots']

        if number_of_shots == 1:
            self.__logger.error('The behavior of getting statevector from simulators'
                                'by setting shots=1 is deprecated and will be removed.'
                                'Use the local_statevector_simulator instead, or place'
                                'explicit snapshot instructions.')
            raise ValueError('Single shot execution not possible!')

        for circuit in circuits:
            operations = circuit['compiled_circuit']['operations']
            operation_names = [operation['name'] for operation in operations]
            if 'measure' not in operation_names:
                self.__logger.warning("No measurements in circuit '%s', classical register will remain all zeros.",
                                      circuit['name'])
